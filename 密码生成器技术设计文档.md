# 密码生成器技术设计文档

## 1. 类结构设计

### 1.1 核心类图
- PasswordGenerator：密码生成器主类
- PasswordConfiguration：配置管理类
- SecureRandomGenerator：安全随机数生成器
- CharacterPool：字符池管理
- PasswordValidator：密码验证器
- StrengthEvaluator：强度评估器

### 1.2 类详细定义

#### PasswordGenerator类
```
public class PasswordGenerator {
    private PasswordConfiguration config;
    private SecureRandomGenerator randomGenerator;
    private CharacterPool characterPool;
    private PasswordValidator validator;
    private StrengthEvaluator strengthEvaluator;
    
    public PasswordGenerator() {
        this.config = new PasswordConfiguration();
        this.randomGenerator = new SecureRandomGenerator();
        this.characterPool = new CharacterPool();
        this.validator = new PasswordValidator();
        this.strengthEvaluator = new StrengthEvaluator();
    }
    
    public PasswordGenerator(PasswordConfiguration config) {
        this.config = config;
        this.randomGenerator = new SecureRandomGenerator();
        this.characterPool = new CharacterPool();
        this.validator = new PasswordValidator();
        this.strengthEvaluator = new StrengthEvaluator();
    }
    
    public String generatePassword() {
        // 生成密码的核心逻辑
    }
    
    public List<String> generateBatch(int count) {
        // 批量生成密码
    }
    
    public StrengthReport evaluatePassword(String password) {
        // 评估密码强度
    }
}
```

#### PasswordConfiguration类
```
public class PasswordConfiguration {
    private int length = 16;
    private boolean useUppercase = true;
    private boolean useLowercase = true;
    private boolean useDigits = true;
    private boolean useSpecialChars = true;
    private boolean excludeSimilarChars = false;
    private String customSpecialChars = null;
    
    // Getters and setters
    public int getLength() { return length; }
    public void setLength(int length) {
        if (length < 8 || length > 128) {
            throw new IllegalArgumentException("Password length must be between 8 and 128");
        }
        this.length = length;
    }
    
    // 其他属性的getter和setter方法
    
    public void validate() {
        // 验证配置是否有效
        int characterTypeCount = 0;
        if (useUppercase) characterTypeCount++;
        if (useLowercase) characterTypeCount++;
        if (useDigits) characterTypeCount++;
        if (useSpecialChars) characterTypeCount++;
        
        if (characterTypeCount < 3) {
            throw new IllegalArgumentException("At least 3 character types must be selected");
        }
    }
}
```

#### SecureRandomGenerator类
```
import java.security.SecureRandom;

public class SecureRandomGenerator {
    private SecureRandom secureRandom;
    
    public SecureRandomGenerator() {
        try {
            this.secureRandom = SecureRandom.getInstanceStrong();
        } catch (Exception e) {
            // 降级到默认实现
            this.secureRandom = new SecureRandom();
            // 强制重新种子化
            byte[] seed = new byte[256];
            secureRandom.nextBytes(seed);
            secureRandom.setSeed(seed);
        }
    }
    
    public int nextInt(int bound) {
        return secureRandom.nextInt(bound);
    }
    
    public char nextChar(char[] chars) {
        int index = secureRandom.nextInt(chars.length);
        return chars[index];
    }
}
```

#### CharacterPool类
```
public class CharacterPool {
    private static final char[] UPPERCASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
    private static final char[] LOWERCASE_CHARS = "abcdefghijklmnopqrstuvwxyz".toCharArray();
    private static final char[] DIGIT_CHARS = "0123456789".toCharArray();
    private static final char[] SPECIAL_CHARS = "!@#$%^&*()-_=+[]{}|;:,.<>?/\"\'.toCharArray();
    private static final char[] SIMILAR_CHARS = "l1Io0O".toCharArray();
    
    public char[] getCharacterPool(PasswordConfiguration config) {
        StringBuilder poolBuilder = new StringBuilder();
        
        if (config.isUseUppercase()) {
            poolBuilder.append(new String(UPPERCASE_CHARS));
        }
        if (config.isUseLowercase()) {
            poolBuilder.append(new String(LOWERCASE_CHARS));
        }
        if (config.isUseDigits()) {
            poolBuilder.append(new String(DIGIT_CHARS));
        }
        if (config.isUseSpecialChars()) {
            if (config.getCustomSpecialChars() != null) {
                poolBuilder.append(config.getCustomSpecialChars());
            } else {
                poolBuilder.append(new String(SPECIAL_CHARS));
            }
        }
        
        String poolStr = poolBuilder.toString();
        
        // 排除相似字符
        if (config.isExcludeSimilarChars()) {
            for (char c : SIMILAR_CHARS) {
                poolStr = poolStr.replace(String.valueOf(c), "");
            }
        }
        
        return poolStr.toCharArray();
    }
    
    public char[][] getCharacterGroups(PasswordConfiguration config) {
        // 返回分组的字符集，用于确保每种类型至少有一个字符
        List<char[]> groups = new ArrayList<>();
        
        if (config.isUseUppercase()) {
            groups.add(filterSimilarChars(UPPERCASE_CHARS, config.isExcludeSimilarChars()));
        }
        // 其他类型的处理
        
        return groups.toArray(new char[0][]);
    }
    
    private char[] filterSimilarChars(char[] chars, boolean excludeSimilar) {
        if (!excludeSimilar) return chars;
        
        StringBuilder filtered = new StringBuilder();
        for (char c : chars) {
            boolean isSimilar = false;
            for (char similar : SIMILAR_CHARS) {
                if (c == similar) {
                    isSimilar = true;
                    break;
                }
            }
            if (!isSimilar) {
                filtered.append(c);
            }
        }
        return filtered.toString().toCharArray();
    }
}
```

## 2. 算法实现

### 2.1 密码生成算法
```
public String generatePassword() {
    config.validate();
    
    char[] characterPool = characterPool.getCharacterPool(config);
    char[][] characterGroups = characterPool.getCharacterGroups(config);
    
    // 创建字符数组存储密码
    char[] password = new char[config.getLength()];
    
    // 确保每种选中的字符类型至少出现一次
    for (int i = 0; i < characterGroups.length; i++) {
        password[i] = randomGenerator.nextChar(characterGroups[i]);
    }
    
    // 填充剩余位置
    for (int i = characterGroups.length; i < password.length; i++) {
        password[i] = randomGenerator.nextChar(characterPool);
    }
    
    // 打乱密码顺序
    shuffleArray(password);
    
    // 检查并修复可能的连续字符
    fixConsecutiveCharacters(password, characterPool);
    
    return new String(password);
}

private void shuffleArray(char[] array) {
    for (int i = array.length - 1; i > 0; i--) {
        int j = randomGenerator.nextInt(i + 1);
        // 交换元素
        char temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}

private void fixConsecutiveCharacters(char[] password, char[] characterPool) {
    for (int i = 1; i < password.length; i++) {
        if (password[i] == password[i - 1]) {
            // 替换为不同的字符
            char newChar;
            do {
                newChar = randomGenerator.nextChar(characterPool);
            } while (newChar == password[i]);
            password[i] = newChar;
        }
    }
}
```

### 2.2 强度评估算法
```
public class StrengthEvaluator {
    public StrengthReport evaluatePassword(String password) {
        int score = 0;
        List<String> suggestions = new ArrayList<>();
        
        // 长度评分
        if (password.length() >= 16) score += 30;
        else if (password.length() >= 12) score += 20;
        else if (password.length() >= 8) score += 10;
        else suggestions.add("密码长度应至少为8个字符");
        
        // 字符类型评分
        boolean hasUppercase = !password.equals(password.toLowerCase());
        boolean hasLowercase = !password.equals(password.toUpperCase());
        boolean hasDigits = password.matches(".*\\d.*");
        boolean hasSpecial = !password.matches("[A-Za-z0-9]*");
        
        int charTypeCount = 0;
        if (hasUppercase) charTypeCount++;
        if (hasLowercase) charTypeCount++;
        if (hasDigits) charTypeCount++;
        if (hasSpecial) charTypeCount++;
        
        score += charTypeCount * 15;
        
        if (charTypeCount < 3) {
            suggestions.add("应使用至少3种不同类型的字符");
        }
        
        // 计算熵值
        double entropy = calculateEntropy(password);
        
        // 检查常见模式
        if (password.matches("12345.*|.*54321|qwerty.*|.*ytrewq")) {
            score -= 20;
            suggestions.add("避免使用连续字符序列");
        }
        
        // 确定强度等级
        String level;
        if (score >= 80) level = "非常强";
        else if (score >= 60) level = "强";
        else if (score >= 40) level = "中";
        else level = "弱";
        
        return new StrengthReport(score, level, entropy, suggestions);
    }
    
    private double calculateEntropy(String password) {
        // 计算密码熵值
        int characterSetSize = 0;
        boolean hasLower = false, hasUpper = false, hasDigit = false, hasSpecial = false;
        
        for (char c : password.toCharArray()) {
            if (Character.isLowerCase(c)) hasLower = true;
            else if (Character.isUpperCase(c)) hasUpper = true;
            else if (Character.isDigit(c)) hasDigit = true;
            else hasSpecial = true;
        }
        
        if (hasLower) characterSetSize += 26;
        if (hasUpper) characterSetSize += 26;
        if (hasDigit) characterSetSize += 10;
        if (hasSpecial) characterSetSize += 32; // 估计的特殊字符数量
        
        // 熵值计算：H = L * log2(N)
        // L是密码长度，N是字符集大小
        return password.length() * (Math.log(characterSetSize) / Math.log(2));
    }
}
```

## 3. 代码规范说明

### 3.1 命名规范
- 类名：采用PascalCase，如PasswordGenerator
- 方法名：采用camelCase，如generatePassword()
- 变量名：采用camelCase，如passwordLength
- 常量名：采用全大写加下划线，如MAX_PASSWORD_LENGTH

### 3.2 安全编码规范
- 敏感数据必须使用char[]而非String存储
- 所有用户输入必须进行验证和过滤
- 禁止在日志中记录密码等敏感信息
- 使用try-finally确保敏感数据及时清除

### 3.3 性能优化规范
- 避免频繁创建临时对象
- 使用StringBuilder代替字符串连接
- 预计算和缓存常用数据
- 避免在循环中进行耗时操作

### 3.4 错误处理规范
- 所有异常必须被适当捕获和处理
- 使用有意义的错误消息
- 提供详细的日志记录用于故障排查
- 实现优雅的降级机制

## 4. 测试策略

### 4.1 单元测试
- 测试密码生成的正确性和随机性
- 测试配置验证的有效性
- 测试强度评估算法的准确性
- 测试边界条件和异常情况

### 4.2 集成测试
- 测试各模块之间的交互
- 测试API接口的功能完整性
- 测试命令行界面的可用性

### 4.3 安全测试
- 进行随机性测试评估
- 执行渗透测试检查安全漏洞
- 进行内存泄漏分析
- 验证密码强度评估的有效性